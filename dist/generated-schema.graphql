# -----------------------------------------------
# !!! THIS FILE WAS GENERATED BY TYPE-GRAPHQL !!!
# !!!   DO NOT MODIFY THIS FILE BY YOURSELF   !!!
# -----------------------------------------------

type AffectedRowsOutput {
  count: Int!
}

type AggregateParkingLot {
  _avg: ParkingLotAvgAggregate
  _count: ParkingLotCountAggregate
  _max: ParkingLotMaxAggregate
  _min: ParkingLotMinAggregate
  _sum: ParkingLotSumAggregate
}

"""
The `BigInt` scalar type represents non-fractional signed whole numeric values.
"""
scalar BigInt

input BigIntFieldUpdateOperationsInput {
  decrement: BigInt
  divide: BigInt
  increment: BigInt
  multiply: BigInt
  set: BigInt
}

input BigIntFilter {
  equals: BigInt
  gt: BigInt
  gte: BigInt
  in: [BigInt!]
  lt: BigInt
  lte: BigInt
  not: NestedBigIntFilter
  notIn: [BigInt!]
}

input BigIntWithAggregatesFilter {
  _avg: NestedFloatFilter
  _count: NestedIntFilter
  _max: NestedBigIntFilter
  _min: NestedBigIntFilter
  _sum: NestedBigIntFilter
  equals: BigInt
  gt: BigInt
  gte: BigInt
  in: [BigInt!]
  lt: BigInt
  lte: BigInt
  not: NestedBigIntWithAggregatesFilter
  notIn: [BigInt!]
}

input EnumParkingLotTypeFieldUpdateOperationsInput {
  set: ParkingLotType
}

input EnumParkingLotTypeFilter {
  equals: ParkingLotType
  in: [ParkingLotType!]
  not: NestedEnumParkingLotTypeFilter
  notIn: [ParkingLotType!]
}

input EnumParkingLotTypeWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedEnumParkingLotTypeFilter
  _min: NestedEnumParkingLotTypeFilter
  equals: ParkingLotType
  in: [ParkingLotType!]
  not: NestedEnumParkingLotTypeWithAggregatesFilter
  notIn: [ParkingLotType!]
}

input IntFieldUpdateOperationsInput {
  decrement: Int
  divide: Int
  increment: Int
  multiply: Int
  set: Int
}

input IntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input IntWithAggregatesFilter {
  _avg: NestedFloatFilter
  _count: NestedIntFilter
  _max: NestedIntFilter
  _min: NestedIntFilter
  _sum: NestedIntFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntWithAggregatesFilter
  notIn: [Int!]
}

type Mutation {
  createManyParkingLot(data: [ParkingLotCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createOneCorrectParkingLot(data: ParkingLotCreateInput!): ParkingLot!
  createOneParkingLot(data: ParkingLotCreateInput!): ParkingLot!
  deleteManyParkingLot(where: ParkingLotWhereInput): AffectedRowsOutput!
  deleteOneParkingLot(where: ParkingLotWhereUniqueInput!): ParkingLot
  updateManyParkingLot(data: ParkingLotUpdateManyMutationInput!, where: ParkingLotWhereInput): AffectedRowsOutput!
  updateOneParkingLot(data: ParkingLotUpdateInput!, where: ParkingLotWhereUniqueInput!): ParkingLot
  upsertOneParkingLot(create: ParkingLotCreateInput!, update: ParkingLotUpdateInput!, where: ParkingLotWhereUniqueInput!): ParkingLot!
}

input NestedBigIntFilter {
  equals: BigInt
  gt: BigInt
  gte: BigInt
  in: [BigInt!]
  lt: BigInt
  lte: BigInt
  not: NestedBigIntFilter
  notIn: [BigInt!]
}

input NestedBigIntWithAggregatesFilter {
  _avg: NestedFloatFilter
  _count: NestedIntFilter
  _max: NestedBigIntFilter
  _min: NestedBigIntFilter
  _sum: NestedBigIntFilter
  equals: BigInt
  gt: BigInt
  gte: BigInt
  in: [BigInt!]
  lt: BigInt
  lte: BigInt
  not: NestedBigIntWithAggregatesFilter
  notIn: [BigInt!]
}

input NestedEnumParkingLotTypeFilter {
  equals: ParkingLotType
  in: [ParkingLotType!]
  not: NestedEnumParkingLotTypeFilter
  notIn: [ParkingLotType!]
}

input NestedEnumParkingLotTypeWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedEnumParkingLotTypeFilter
  _min: NestedEnumParkingLotTypeFilter
  equals: ParkingLotType
  in: [ParkingLotType!]
  not: NestedEnumParkingLotTypeWithAggregatesFilter
  notIn: [ParkingLotType!]
}

input NestedFloatFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatFilter
  notIn: [Float!]
}

input NestedIntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input NestedIntWithAggregatesFilter {
  _avg: NestedFloatFilter
  _count: NestedIntFilter
  _max: NestedIntFilter
  _min: NestedIntFilter
  _sum: NestedIntFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntWithAggregatesFilter
  notIn: [Int!]
}

input NestedStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedStringFilter
  _min: NestedStringFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

type ParkingLot {
  contact: BigInt!
  id: String!
  name: String!
  parkingType: ParkingLotType!
  spots: Int!
}

type ParkingLotAvgAggregate {
  contact: Float
  spots: Float
}

input ParkingLotAvgOrderByAggregateInput {
  contact: SortOrder
  spots: SortOrder
}

input ParkingLotCheckInInput {
  parkingLotId: String!
  userType: UserType!
}

type ParkingLotCountAggregate {
  _all: Int!
  contact: Int!
  id: Int!
  name: Int!
  parkingType: Int!
  spots: Int!
}

input ParkingLotCountOrderByAggregateInput {
  contact: SortOrder
  id: SortOrder
  name: SortOrder
  parkingType: SortOrder
  spots: SortOrder
}

input ParkingLotCreateInput {
  contact: BigInt!
  id: String
  name: String!
  parkingType: ParkingLotType!
  spots: Int!
}

input ParkingLotCreateManyInput {
  contact: BigInt!
  id: String
  name: String!
  parkingType: ParkingLotType!
  spots: Int!
}

type ParkingLotGroupBy {
  _avg: ParkingLotAvgAggregate
  _count: ParkingLotCountAggregate
  _max: ParkingLotMaxAggregate
  _min: ParkingLotMinAggregate
  _sum: ParkingLotSumAggregate
  contact: BigInt!
  id: String!
  name: String!
  parkingType: ParkingLotType!
  spots: Int!
}

type ParkingLotMaxAggregate {
  contact: BigInt
  id: String
  name: String
  parkingType: ParkingLotType
  spots: Int
}

input ParkingLotMaxOrderByAggregateInput {
  contact: SortOrder
  id: SortOrder
  name: SortOrder
  parkingType: SortOrder
  spots: SortOrder
}

type ParkingLotMinAggregate {
  contact: BigInt
  id: String
  name: String
  parkingType: ParkingLotType
  spots: Int
}

input ParkingLotMinOrderByAggregateInput {
  contact: SortOrder
  id: SortOrder
  name: SortOrder
  parkingType: SortOrder
  spots: SortOrder
}

input ParkingLotOrderByWithAggregationInput {
  _avg: ParkingLotAvgOrderByAggregateInput
  _count: ParkingLotCountOrderByAggregateInput
  _max: ParkingLotMaxOrderByAggregateInput
  _min: ParkingLotMinOrderByAggregateInput
  _sum: ParkingLotSumOrderByAggregateInput
  contact: SortOrder
  id: SortOrder
  name: SortOrder
  parkingType: SortOrder
  spots: SortOrder
}

input ParkingLotOrderByWithRelationInput {
  contact: SortOrder
  id: SortOrder
  name: SortOrder
  parkingType: SortOrder
  spots: SortOrder
}

enum ParkingLotScalarFieldEnum {
  contact
  id
  name
  parkingType
  spots
}

input ParkingLotScalarWhereWithAggregatesInput {
  AND: [ParkingLotScalarWhereWithAggregatesInput!]
  NOT: [ParkingLotScalarWhereWithAggregatesInput!]
  OR: [ParkingLotScalarWhereWithAggregatesInput!]
  contact: BigIntWithAggregatesFilter
  id: StringWithAggregatesFilter
  name: StringWithAggregatesFilter
  parkingType: EnumParkingLotTypeWithAggregatesFilter
  spots: IntWithAggregatesFilter
}

type ParkingLotSumAggregate {
  contact: BigInt
  spots: Int
}

input ParkingLotSumOrderByAggregateInput {
  contact: SortOrder
  spots: SortOrder
}

enum ParkingLotType {
  courtesy
  private
  public
}

input ParkingLotUpdateInput {
  contact: BigIntFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  parkingType: EnumParkingLotTypeFieldUpdateOperationsInput
  spots: IntFieldUpdateOperationsInput
}

input ParkingLotUpdateManyMutationInput {
  contact: BigIntFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  parkingType: EnumParkingLotTypeFieldUpdateOperationsInput
  spots: IntFieldUpdateOperationsInput
}

input ParkingLotWhereInput {
  AND: [ParkingLotWhereInput!]
  NOT: [ParkingLotWhereInput!]
  OR: [ParkingLotWhereInput!]
  contact: BigIntFilter
  id: StringFilter
  name: StringFilter
  parkingType: EnumParkingLotTypeFilter
  spots: IntFilter
}

input ParkingLotWhereUniqueInput {
  id: String
  name: String
}

type Query {
  aggregateParkingLot(cursor: ParkingLotWhereUniqueInput, orderBy: [ParkingLotOrderByWithRelationInput!], skip: Int, take: Int, where: ParkingLotWhereInput): AggregateParkingLot!
  findFirstParkingLot(cursor: ParkingLotWhereUniqueInput, distinct: [ParkingLotScalarFieldEnum!], orderBy: [ParkingLotOrderByWithRelationInput!], skip: Int, take: Int, where: ParkingLotWhereInput): ParkingLot
  findFirstParkingLotOrThrow(cursor: ParkingLotWhereUniqueInput, distinct: [ParkingLotScalarFieldEnum!], orderBy: [ParkingLotOrderByWithRelationInput!], skip: Int, take: Int, where: ParkingLotWhereInput): ParkingLot
  getParkingLot(where: ParkingLotWhereUniqueInput!): ParkingLot
  groupByParkingLot(by: [ParkingLotScalarFieldEnum!]!, having: ParkingLotScalarWhereWithAggregatesInput, orderBy: [ParkingLotOrderByWithAggregationInput!], skip: Int, take: Int, where: ParkingLotWhereInput): [ParkingLotGroupBy!]!
  parkingLot(where: ParkingLotWhereUniqueInput!): ParkingLot
  parkingLotCheckIn(data: ParkingLotCheckInInput!): String!
  parkingLots(cursor: ParkingLotWhereUniqueInput, distinct: [ParkingLotScalarFieldEnum!], orderBy: [ParkingLotOrderByWithRelationInput!], skip: Int, take: Int, where: ParkingLotWhereInput): [ParkingLot!]!
}

enum QueryMode {
  default
  insensitive
}

enum SortOrder {
  asc
  desc
}

input StringFieldUpdateOperationsInput {
  set: String
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input StringWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedStringFilter
  _min: NestedStringFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

enum UserType {
  corporate
  provider
  visitor
}
